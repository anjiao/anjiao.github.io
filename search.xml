<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot参数校验和统一处理]]></title>
    <url>%2F2018%2F12%2F28%2FSpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、新建项目运行环境1.1项目目录 1.2启动运行修改application.properties端口 1server.port= 9090 User实体和Controller 123456789101112131415161718192021222324252627282930public class User implements Serializable &#123; private Integer id; private String name; private String emial; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getEmial() &#123; return emial; &#125; public void setEmial(String emial) &#123; this.emial = emial; &#125;&#125; 123456789@RestController@RequestMapping("/user")public class TestController &#123; @RequestMapping("/updateUserInfo") public String updateUserInfo() &#123; return "你好"; &#125;&#125; 启动之后打开浏览器输入http://localhost:9090/user/updateUserInfo，运行成功 2、一般的代码参数验证为updateUserInfo添加User参数并判断用户名不能为空的情况 123456789101112@RestController@RequestMapping("/user")public class TestController &#123; @RequestMapping("/updateUserInfo") public String updateUserInfo(@RequestBody User user) &#123; if (user.getName() == null || user.getName().length() == 0) &#123; return "用户名不能为空哦亲~~~"; &#125; return "你好"; &#125;&#125; 我们来请求一下数据，先来请求一下完整的数据，如下图 因为我们代码中添加了用户名字的判断，下面我们不传用户名字的参数，如下图 3、注解方式验证做如下代码改动，在Controller和User实体中加入@NotNull和@Valid 123456public class User implements Serializable &#123; private Integer id; @NotNull(message = "姓名不能为空") private String name; private String emial; 123456789@RestController@RequestMapping("/user")public class TestController &#123; @RequestMapping("/updateUserInfo") public String updateUserInfo(@RequestBody @Valid User user) &#123; return "你好"; &#125;&#125; 加上以上配置之后请求用户为空返回如下，这是因为，默认情况下，SpringBoot配置了默认异常处理器DefaultHandlerExceptionResolver，而该处理器仅仅是将异常信息打印出来。 12345678910111213141516171819202122232425262728293031323334&#123; "timestamp": "2018-12-28T03:30:49.942+0000", "status": 400, "error": "Bad Request", "errors": [ &#123; "codes": [ "NotNull.user.name", "NotNull.name", "NotNull.java.lang.String", "NotNull" ], "arguments": [ &#123; "codes": [ "user.name", "name" ], "arguments": null, "defaultMessage": "name", "code": "name" &#125; ], "defaultMessage": "姓名不能为空", "objectName": "user", "field": "name", "rejectedValue": null, "bindingFailure": false, "code": "NotNull" &#125; ], "message": "Validation failed for object='user'. Error count: 1", "path": "/user/updateUserInfo"&#125; 显然，我们并不需要返回如此多的信息，只需要将对应属性中的message信息给调用者即可，我们使用两种方式来解决。 3.1 方式一添加BindingResult改进Controller 123456789101112131415@RestController@RequestMapping("/user")public class TestController &#123; @RequestMapping("/updateUserInfo") public String updateUserInfo(@RequestBody @Valid User user, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; List&lt;ObjectError&gt; errorList = bindingResult.getAllErrors(); if (errorList != null &amp;&amp; errorList.size() &gt; 0) &#123; return errorList.get(0).getDefaultMessage(); &#125; &#125; return "你好"; &#125;&#125; 重启运行看结果如下图，成功返回了我们想看到的 message 但是这样并不优雅，每次都需要处理手动调用还要加入BindingResult参数 ### 3.2 方式二全局异常捕获 新建`GlobalExceptionHandler`类 undefined 改进`Controller` undefined 得到同样的效果 ![](http://pjk6kg9m3.bkt.clouddn.com/valid_4.png) 这里就可以统一处理我们的参数异常情况了，推荐 4、其他 spring boot 是引入了hibernate-validator的支持，由于默认情况下，Hibernate-validator使用的校验策略是依次校验，并且将不通过的结果保存，最后再统一抛出异常信息，但实际上，当校验出现第一个不满足情况的时候，就可以停止了(当然，如果选择全部验证完也是可以的)，所以我们手动配置一下。 我们先看一下，如果是多个参数的校验 1234567public class User implements Serializable &#123; private Integer id; @NotNull(message = "姓名不能为空") private String name; @NotNull(message = "Email不能为空") private String emial; 返回信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; "timestamp": "2018-12-28T06:03:12.485+0000", "status": 400, "error": "Bad Request", "errors": [ &#123; "codes": [ "NotNull.user.name", "NotNull.name", "NotNull.java.lang.String", "NotNull" ], "arguments": [ &#123; "codes": [ "user.name", "name" ], "arguments": null, "defaultMessage": "name", "code": "name" &#125; ], "defaultMessage": "姓名不能为空", "objectName": "user", "field": "name", "rejectedValue": null, "bindingFailure": false, "code": "NotNull" &#125;, &#123; "codes": [ "NotNull.user.emial", "NotNull.emial", "NotNull.java.lang.String", "NotNull" ], "arguments": [ &#123; "codes": [ "user.emial", "emial" ], "arguments": null, "defaultMessage": "emial", "code": "emial" &#125; ], "defaultMessage": "Email不能为空", "objectName": "user", "field": "emial", "rejectedValue": null, "bindingFailure": false, "code": "NotNull" &#125; ], "message": "Validation failed for object='user'. Error count: 2", "path": "/user/updateUserInfo"&#125; 我们添加如下的配置之后 123456789101112@Configurationpublic class ValidatorConfig &#123; @Bean public Validator validator() &#123; ValidatorFactory factory = Validation.byProvider(HibernateValidator.class) .configure() // 将fail_fast设置为true即可，如果想验证全部，则设置为false或者取消配置即可 .addProperty("hibernate.validator.fail_fast", "true") .buildValidatorFactory(); return factory.getValidator(); &#125;&#125; 只返回了姓名的校验，而不是全部返回了 12345678910111213141516171819202122232425262728293031323334&#123; "timestamp": "2018-12-28T06:05:45.525+0000", "status": 400, "error": "Bad Request", "errors": [ &#123; "codes": [ "NotNull.user.name", "NotNull.name", "NotNull.java.lang.String", "NotNull" ], "arguments": [ &#123; "codes": [ "user.name", "name" ], "arguments": null, "defaultMessage": "name", "code": "name" &#125; ], "defaultMessage": "姓名不能为空", "objectName": "user", "field": "name", "rejectedValue": null, "bindingFailure": false, "code": "NotNull" &#125; ], "message": "Validation failed for object='user'. Error count: 1", "path": "/user/updateUserInfo"&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YAML语法入门和介绍]]></title>
    <url>%2F2018%2F12%2F24%2FYAML%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%E5%92%8C%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1、基本格式要求一个在线格式示例 YAML大小写敏感 使用缩进代表层级 同级缩进一样 #也使用做注释 2、示例展示随便拷贝了一个项目开源的示例 123456789101112131415161718192021222324252627282930313233343536server: port: 8080guns: swagger-open: true #是否开启swagger (true/false) kaptcha-open: false #是否开启登录时验证码 (true/false) # file-upload-path: d:/tmp #文件上传目录(不配置的话为java.io.tmpdir目录) spring-session-open: false #是否开启spring session,如果是多机环境需要开启(true/false) session-invalidate-time: 1800 #session失效时间(只在单机环境下生效，多机环境在SpringSessionConfig类中配置) 单位：秒 session-validation-interval: 900 #多久检测一次失效的session(只在单机环境下生效) 单位：秒beetl: resource-auto-check: true #热加载beetl模板，开发时候用spring: profiles: active: @spring.active@ mvc: static-path-pattern: /static/** view: prefix: /WEB-INF/view devtools: restart: enabled: false additional-paths: src/main/java exclude: static/**,WEB-INF/view/** servlet: multipart: max-request-size: 100MB max-file-size: 100MBmybatis-plus: typeAliasesPackage: cn.stylefeng.guns.modular.system.modellog: path: guns-logs 3、使用介绍3.1对象格式 key: value ，冒号后面摇加一个空格 1key: value 3.2层级使用缩进来表示层级 1234567server: port: 9090 spring: datasource: url: 也可以使用流式语法 1key: &#123;child-key1: value1, child-key2: value2&#125; 3.3数组使用一个短横线加一个空格代表一个数组 12345678910seq: - Mercury # Rotates - no light/dark sides. - Venus # Deadliest. Aptly named. - Earth # Mostly dirt. - Mars # Seems empty. - Jupiter # The king. - Saturn # Pretty. - Uranus # Where the sun hardly shines. - Neptune # Boring. No rings. - Pluto # You call this a planet? 相对复杂一点的 123456789key: - id: 1 name: nihao age: 18 - id: 2 name: nihao age: 18 流式 1key: [&#123;id: 1,name: nihao,age: 18&#125;,&#123;id: 2,name: nihao,age: 18&#125;] 3.4常量YAML支持多种常量：整数、浮点、字符串、NULL、日期、布尔、时间 3.5一些特殊符号3.5.1注解使用 #3.5.2表示一个文档的开始 ---例如 12345678910111213141516171819---spring: profiles: dev datasource: url: jdbc:mysql://127.0.0.1:3306/guns?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=CONVERT_TO_NULL&amp;useSSL=false&amp;serverTimezone=CTT username: root password: root filters: wall,mergeStat---spring: profiles: test datasource: url: jdbc:mysql://127.0.0.1:3306/guns?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=CONVERT_TO_NULL&amp;useSSL=false&amp;serverTimezone=CTT username: root password: root filters: wall,mergeStat 3.5.3 … 和—配合在一个配置文件中代表一个文件的结束 123456789---spring: profiles: test datasource: url: jdbc:mysql://127.0.0.1:3306/guns?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=CONVERT_TO_NULL&amp;useSSL=false&amp;serverTimezone=CTT username: root password: root filters: wall,mergeStat ... 4、其他使用参考YAML 语言教程 YAML 1.2 规格]]></content>
      <tags>
        <tag>YAML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter基于Mac环境安装到AS真机运行]]></title>
    <url>%2F2018%2F12%2F18%2FFlutter%E5%9F%BA%E4%BA%8EMac%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%88%B0AS%E7%9C%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[官方链接和前置环境官方地址 Flutter中文网 前置环境： 已安装了android studio 并且配置好能开发 下载Flutter SDK配置路径和下载Flutter SDK 123export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn git clone -b dev https://github.com/flutter/flutter.git 配置路径打开命令行输入 1open -e .bash_profile 打开文件之后添加两个路径 12export PATH=$&#123;PATH&#125;:/Users/joe/flutter/bin:$PATHexport ANDROID_HOME=/Users/joe/Documents/androidadt/adt-bundle-mac-x86_64-20140702/sdk 第一个路径：设置Flutter路径 第二个路径：设置Flutter识别的Android SDK 路径 如果第二个路径没配置可能会提示说安卓sdk找不到 设置之后记得更新配置 1source .bash_profile 验证安装环境输入命令行输入 1flutter doctor 如果提示Flutter找不到指令，上面路径一忘记设置 如果提示Android SDK无法关联，上面路径二忘记设置 都打钩了就说明环境配置OK了 Android Studio 插件安装在plugin中搜索Dart和Flutter并且安装，重启As，会出现新建Flutter项目选项，新建Helloworld项目，流水式的新建，就不贴图了 真机运行插上手机，运行即可，如果安装了Xcode，也可以选择IOS模拟器来运行。输入flutter doctor指令的时候如果提示需要统一一些 协议，会提示你输入什么命令，按照提示输入即可。 附图 真机效果图]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora 快捷键记录]]></title>
    <url>%2F2018%2F12%2F17%2FTypora%20%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Typora是个人写博客的MarkDown写作工具，记录一下它一些常用的快捷键，便于日后查询 1、标题和段落相关插入 1 - 6 级的标题1command + (1-6) 光标放在所在的行即可操作 标题降级和升级1command + (+或者-) 来升级和降级 光标放在所在的行即可操作 插入文本即段落1command + 0 (零不是欧) 2、插入区块相关插入表格1option + command + T 例如 用户名 Email 年龄 隔壁老王 88@qq.com 18 插入代码块1option + command + C 插入公式块1option + command + B 例如$$x+y=b$$ 插入引用1option + command + Q 例如 近几年来，父亲和我都是东奔西走，家中光景是一日不如一日。他少年出外谋生，独力支持，做了许多大事。哪知老境却如此颓唐！他触目伤怀，自然情不能自已。 （摘自：背影） 3、列表相关有序列表1option + command + O (欧) 有序一 有序二 有序三 无序列表1option + command + U 无序一 无序二 无序三 任务列表1option + command + X 任务一 任务二 任务三 列表增大和减少缩进12增大列表缩进 command + ]减少列表缩进 command + [ 任务一 任务一子任务 任务二 任务二字任务 4、其他链接引用1option + command + L 脚注1option + command + R 水平分割线1Shift + command + - 生成Toc目录无快捷键，需要点击段落然后生成就好了 5、默认支持加粗1command + B 我是对应的加粗文字 斜体1command + I 我是对应的斜体文字 下划线文字1command + U 我是对应的下划线文字 代码1shift + command + ’ 我是代码实例我继续添加一些内容再来个代码实例 注释1control + - 超链接1command + K (文字+链接) 我是超链接文字 图片1control + command + I 6、其他实用操作源代码模式切换1command + /]]></content>
      <categories>
        <category>开发技巧</category>
      </categories>
      <tags>
        <tag>开发技巧</tag>
      </tags>
  </entry>
</search>
